digraph "graph&lt; index_t, scalar_t &gt;"
{
 // LATEX_PDF_SIZE
  bgcolor="transparent";
  edge [fontname=Helvetica,fontsize=8,labelfontname=Helvetica,labelfontsize=8];
  node [fontname=Helvetica,fontsize=8,shape=box,height=0.2,width=0.4];
  Node1 [id="Node000001",shape=plain,label=<<TABLE CELLBORDER="0" BORDER="1"><TR><TD COLSPAN="2" CELLPADDING="1" CELLSPACING="0">graph&lt; index_t, scalar_t &gt;</TD></TR>
<HR/>
<TR><TD COLSPAN="2" CELLPADDING="1" CELLSPACING="0">&nbsp;</TD></TR>
<HR/>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">graph(std::pmr::memory_resource *_resource=std::pmr::get_default_resource()) noexcept<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">graph(const std::initializer_list&lt; std::initializer_list&lt; edge_t &gt; &gt; &amp;_adjacency_list, std::pmr::memory_resource *_resource=std::pmr::get_default_resource())<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">graph(const grid&lt; coord_t, weight_t &gt; &amp;_grid, std::pmr::memory_resource *_resource=std::pmr::get_default_resource())<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">void add(index_t _from_id)<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">void add(index_t _from_id, const edge_t &amp;_edge)<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">void remove(index_t _from_id, const edge_t &amp;_edge) noexcept<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">void prune()<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">const neighbours_t &amp; get_neighbours(index_t _id) const<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">bool contains(index_t _id) const noexcept<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">size_t count() const noexcept<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">void clear() noexcept<BR ALIGN="LEFT"/></TD></TR>
<TR><TD VALIGN="top" CELLPADDING="1" CELLSPACING="0">*</TD><TD VALIGN="top" ALIGN="LEFT" CELLPADDING="1" CELLSPACING="0">const auto &amp; operator[](const index_t &amp;_id) const noexcept<BR ALIGN="LEFT"/></TD></TR>
</TABLE>>
,height=0.2,width=0.4,color="gray40", fillcolor="grey60", style="filled", fontcolor="black",tooltip="Graph structure for use in maze-solving algorithms."];
}
